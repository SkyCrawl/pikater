package org.pikater.core.utilities.evolution;

import org.pikater.core.utilities.evolution.individuals.Individual;
import org.pikater.core.utilities.evolution.operators.Operator;
import org.pikater.core.utilities.evolution.selectors.Selector;

import java.util.ArrayList;

/** The main class which is responsible for the run of a single generation of
 * the evolutionary algorithm. Provides a way to specify the fitness function,
 * operators, and selectors used during the evolution. Also the size of the
 * elite can be specified.
 *
 * @author Martin Pilat
 */
public class EvolutionaryAlgorithm {

    ArrayList<Operator> operators;
    ArrayList<Selector> matingSelectors;
    ArrayList<Selector> environmentalSelectors;
    double eliteSize = 0.0;
    FitnessEvaluator fitness;
    Replacement replacement;

    /**
     * Initializes an empty evolutionary algorithm. Replacement is set to the
     * instance of SGAReplacement. All other values remain unset.
     */
    public EvolutionaryAlgorithm() {
        operators = new ArrayList<Operator>();
        matingSelectors = new ArrayList<Selector>();
        environmentalSelectors = new ArrayList<Selector>();
        replacement = new SGAReplacement();
    }

    /**
     * Setter for the replacement.
     * @param replacement The replacement which shall be used.
     */
    public void setReplacement(Replacement replacement) {
        this.replacement = replacement;
    }

    /**
     * Specifies the size of the elite which shall be used.
     *
     * @param elitePercentage The percentage of population which shall be used as
     * elite. Should be number between 0.0 and 1.0 (inclusive).
     */
    public void setElite(double elitePercentage) {
        eliteSize = elitePercentage;
    }

    /**
     * Adds a new genetic operator to the queue of genetic operators.
     * @param o The operator which should be added.
     */
    public void addOperator(Operator o) {
        operators.add(o);
    }

    /**
     * Adds a new mating selector the the queue of mating selectors.
     * @param s The selector which shall be added.
     */

    public void addMatingSelector(Selector s) {
        matingSelectors.add(s);
    }

    /**
     * Adds a new environmental sector to the queue of environmental selectors.
     * @param s The environmental selector which shall be added.
     */
    public void addEnvironmentalSelector(Selector s) {
        environmentalSelectors.add(s);
    }

    /**
     * Sets the fitness function which is maximized by the evolutionary algoritm.
     *
     * Internally this method creates an instance of SimpleEvaluater which is used
     * the evaluate the whole population.
     * 
     * @param f The fitness function which shall be used.
     *
     */
    public void setFitnessFunction(FitnessFunction f) {
        fitness = new SimpleEvaluator(f);
    }

    /**
     * Sets the fitness evaluator which evaluates the whole population at once. This allows
     * to assign fitness to individuals even if the fitness of particular individual
     * depends on the fitness of other individuals in the population.
     * 
     * @param fe The fitness evaluator which shall be used. Must assign fitness to all
     * individuals in the population.
     */

    public void setFitnessEvaluator(FitnessEvaluator fe) {
        fitness = fe;
    }

    /**
     * Executes one generation of the evolutionary algorithm.
     *
     * First, the mating selectors are used to create the mating pool. In this
     * step, if there are n mating selectors, each of them selects 1/n of the
     * population. The last specified selector may select more individuals to make
     * the population size constant.
     *
     * Next, the specified operators are executed in the order they were specified.
     * The population generated by an operator is used as the input for the next
     * operator in the queue.
     *
     * Then, the selection starts. First, the specified number of elite individuals
     * is added to the population of selected individuals. Then the parent and
     * offspring populations are combined using the replacement specified and
     * environmental selections are executed to select individuals from the combined
     * population. The process is similar to the one used for mating selectors.
     * 
     * Finally, the individuals in the input population are replaced by the newly
     * selected individuals.
     *
     * @param pop The population on which the single generation shall be run.
     */

    public void evolve(Population pop) {

        if (fitness == null)
            throw new IllegalStateException("No fitness function defined");

        fitness.evaluate(pop);

        Population parents = pop;
        
        Population matingPool = new Population();

        if (matingSelectors.size() > 0) {
            int mateSel = matingSelectors.size();
            int toSelect = parents.getPopulationSize()/mateSel;
            for (int i = 0; i < matingSelectors.size(); i++) {
                Population sel = new Population();
                matingSelectors.get(i).select(toSelect, parents, sel);
                matingPool.addAll((Population)sel.clone());
            }

            int missing = parents.getPopulationSize() - matingPool.getPopulationSize();
            if (missing > 0) {
                Population sel = new Population();
                matingSelectors.get(matingSelectors.size()-1).select(toSelect, parents, sel);
                matingPool.addAll((Population)sel.clone());
            }
        } else
        {
            matingPool = (Population)parents.clone();
        }

        Population offspring = null;
        for (Operator o : operators) {
            offspring = new Population();
            o.operate(matingPool, offspring);
            matingPool = offspring;
        }

        fitness.evaluate(offspring);

        Population selected = new Population();

        ArrayList<Individual> sortedOld = parents.getSortedIndividuals();
        for (int i = 0; i < eliteSize*parents.getPopulationSize(); i++) {
            selected.add(sortedOld.get(i));
        }

        Population combined = replacement.replace(parents, offspring);

        fitness.evaluate(combined);

        int envSel = environmentalSelectors.size();
        int toSelect = (parents.getPopulationSize() - selected.getPopulationSize())/envSel;
        for (int i = 0; i < environmentalSelectors.size(); i++) {
            Population sel = new Population();
            environmentalSelectors.get(i).select(toSelect, combined, sel);
            selected.addAll((Population)sel.clone());
        }

        int missing = parents.getPopulationSize() - selected.getPopulationSize();
        if (missing > 0) {
            Population sel = new Population();
            environmentalSelectors.get(environmentalSelectors.size() - 1).select(toSelect, combined, sel);
            selected.addAll((Population)sel.clone());
        }

        pop.clear();
        pop.addAll(selected);

        fitness.evaluate(pop);
    }


}
